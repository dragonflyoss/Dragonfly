// Code generated by go-swagger; DO NOT EDIT.

package types

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"encoding/json"

	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TaskInfo detailed information about task in supernode.
// swagger:model TaskInfo
type TaskInfo struct {

	// ID of the task.
	ID string `json:"ID,omitempty"`

	// This attribute represents the node as a seed node for the taskURL.
	//
	AsSeed bool `json:"asSeed,omitempty"`

	// The status of the created task related to CDN functionality.
	//
	// Enum: [WAITING RUNNING FAILED SUCCESS SOURCE_ERROR]
	CdnStatus string `json:"cdnStatus,omitempty"`

	// The length of the file dfget requests to download in bytes
	// which including the header and the trailer of each piece.
	//
	FileLength int64 `json:"fileLength,omitempty"`

	// extra HTTP headers sent to the rawURL.
	// This field is carried with the request to supernode.
	// Supernode will extract these HTTP headers, and set them in HTTP downloading requests
	// from source server as user's wish.
	//
	Headers map[string]string `json:"headers,omitempty"`

	// The length of the source file in bytes.
	//
	HTTPFileLength int64 `json:"httpFileLength,omitempty"`

	// special attribute of remote source file. This field is used with taskURL to generate new taskID to
	// identify different downloading task of remote source file. For example, if user A and user B uses
	// the same taskURL and taskID to download file, A and B will share the same peer network to distribute files.
	// If user A additionally adds an identifier with taskURL, while user B still carries only taskURL, then A's
	// generated taskID is different from B, and the result is that two users use different peer networks.
	//
	Identifier string `json:"identifier,omitempty"`

	// md5 checksum for the resource to distribute. dfget catches this parameter from dfget's CLI
	// and passes it to supernode. When supernode finishes downloading file/image from the source location,
	// it will validate the source file with this md5 value to check whether this is a valid file.
	//
	Md5 string `json:"md5,omitempty"`

	// The size of pieces which is calculated as per the following strategy
	// 1. If file's total size is less than 200MB, then the piece size is 4MB by default.
	// 2. Otherwise, it equals to the smaller value between totalSize/100MB + 2 MB and 15MB.
	//
	PieceSize int32 `json:"pieceSize,omitempty"`

	// piece total
	PieceTotal int32 `json:"pieceTotal,omitempty"`

	// The is the resource's URL which user uses dfget to download. The location of URL can be anywhere, LAN or WAN.
	// For image distribution, this is image layer's URL in image registry.
	// The resource url is provided by command line parameter.
	//
	RawURL string `json:"rawURL,omitempty"`

	// when supernode finishes downloading file/image from the source location,
	// the md5 sum of the source file will be calculated as the value of the realMd5.
	// And it will be used to compare with md5 value to check whether this is a valid file.
	//
	RealMd5 string `json:"realMd5,omitempty"`

	// taskURL is generated from rawURL. rawURL may contains some queries or parameter, dfget will filter some queries via
	// --filter parameter of dfget. The usage of it is that different rawURL may generate the same taskID.
	//
	TaskURL string `json:"taskURL,omitempty"`
}

// Validate validates this task info
func (m *TaskInfo) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCdnStatus(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

var taskInfoTypeCdnStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["WAITING","RUNNING","FAILED","SUCCESS","SOURCE_ERROR"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		taskInfoTypeCdnStatusPropEnum = append(taskInfoTypeCdnStatusPropEnum, v)
	}
}

const (

	// TaskInfoCdnStatusWAITING captures enum value "WAITING"
	TaskInfoCdnStatusWAITING string = "WAITING"

	// TaskInfoCdnStatusRUNNING captures enum value "RUNNING"
	TaskInfoCdnStatusRUNNING string = "RUNNING"

	// TaskInfoCdnStatusFAILED captures enum value "FAILED"
	TaskInfoCdnStatusFAILED string = "FAILED"

	// TaskInfoCdnStatusSUCCESS captures enum value "SUCCESS"
	TaskInfoCdnStatusSUCCESS string = "SUCCESS"

	// TaskInfoCdnStatusSOURCEERROR captures enum value "SOURCE_ERROR"
	TaskInfoCdnStatusSOURCEERROR string = "SOURCE_ERROR"
)

// prop value enum
func (m *TaskInfo) validateCdnStatusEnum(path, location string, value string) error {
	if err := validate.Enum(path, location, value, taskInfoTypeCdnStatusPropEnum); err != nil {
		return err
	}
	return nil
}

func (m *TaskInfo) validateCdnStatus(formats strfmt.Registry) error {

	if swag.IsZero(m.CdnStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateCdnStatusEnum("cdnStatus", "body", m.CdnStatus); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskInfo) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskInfo) UnmarshalBinary(b []byte) error {
	var res TaskInfo
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
