// Code generated by go-swagger; DO NOT EDIT.

package types

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// TaskCreateRequest task create request
// swagger:model TaskCreateRequest
type TaskCreateRequest struct {

	// CID means the client ID. It maps to the specific dfget process.
	// When user wishes to download an image/file, user would start a dfget process to do this.
	// This dfget is treated a client and carries a client ID.
	// Thus, multiple dfget processes on the same peer have different CIDs.
	//
	CID string `json:"cID,omitempty"`

	// This attribute represents where the dfget requests come from. Dfget will pass
	// this field to supernode and supernode can do some checking and filtering via
	// black/white list mechanism to guarantee security, or some other purposes like debugging.
	//
	// Min Length: 1
	CallSystem string `json:"callSystem,omitempty"`

	// tells whether it is a call from dfdaemon. dfdaemon is a long running
	// process which works for container engines. It translates the image
	// pulling request into raw requests into those dfget recognizes.
	//
	Dfdaemon bool `json:"dfdaemon,omitempty"`

	// This attribute represents the length of resource, dfdaemon or dfget catches and calculates
	// this parameter from the headers of request URL. If fileLength is vaild, the supernode need
	// not get the length of resource by accessing the rawURL.
	//
	FileLength int64 `json:"fileLength,omitempty"`

	// filter is used to filter request queries in URL.
	// For example, when a user wants to start to download a task which has a remote URL of
	// a.b.com/fileA?user=xxx&auth=yyy, user can add a filter parameter ["user", "auth"]
	// to filter the url to a.b.com/fileA. Then this parameter can potentially avoid repeatable
	// downloads, if there is already a task a.b.com/fileA.
	//
	Filter []string `json:"filter"`

	// extra HTTP headers sent to the rawURL.
	// This field is carried with the request to supernode.
	// Supernode will extract these HTTP headers, and set them in HTTP downloading requests
	// from source server as user's wish.
	//
	Headers map[string]string `json:"headers,omitempty"`

	// special attribute of remote source file. This field is used with taskURL to generate new taskID to
	// identify different downloading task of remote source file. For example, if user A and user B uses
	// the same taskURL and taskID to download file, A and B will share the same peer network to distribute files.
	// If user A additionally adds an identifier with taskURL, while user B still carries only taskURL, then A's
	// generated taskID is different from B, and the result is that two users use different peer networks.
	//
	Identifier string `json:"identifier,omitempty"`

	// md5 checksum for the resource to distribute. dfget catches this parameter from dfget's CLI
	// and passes it to supernode. When supernode finishes downloading file/image from the source location,
	// it will validate the source file with this md5 value to check whether this is a valid file.
	//
	Md5 string `json:"md5,omitempty"`

	// path is used in one peer A for uploading functionality. When peer B hopes
	// to get piece C from peer A, B must provide a URL for piece C.
	// Then when creating a task in supernode, peer A must provide this URL in request.
	//
	Path string `json:"path,omitempty"`

	// PeerID is used to uniquely identifies a peer which will be used to create a dfgetTask.
	// The value must be the value in the response after registering a peer.
	//
	PeerID string `json:"peerID,omitempty"`

	// The is the resource's URL which user uses dfget to download. The location of URL can be anywhere, LAN or WAN.
	// For image distribution, this is image layer's URL in image registry.
	// The resource url is provided by command line parameter.
	//
	RawURL string `json:"rawURL,omitempty"`

	// IP address of supernode which the peer connects to
	SupernodeIP string `json:"supernodeIP,omitempty"`

	// This attribute represents the digest of resource, dfdaemon or dfget catches this parameter
	// from the headers of request URL. The digest will be considered as the taskID if not null.
	//
	TaskID string `json:"taskId,omitempty"`

	// taskURL is generated from rawURL. rawURL may contains some queries or parameter, dfget will filter some queries via
	// --filter parameter of dfget. The usage of it is that different rawURL may generate the same taskID.
	//
	TaskURL string `json:"taskURL,omitempty"`
}

// Validate validates this task create request
func (m *TaskCreateRequest) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCallSystem(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *TaskCreateRequest) validateCallSystem(formats strfmt.Registry) error {

	if swag.IsZero(m.CallSystem) { // not required
		return nil
	}

	if err := validate.MinLength("callSystem", "body", string(m.CallSystem), 1); err != nil {
		return err
	}

	return nil
}

// MarshalBinary interface implementation
func (m *TaskCreateRequest) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *TaskCreateRequest) UnmarshalBinary(b []byte) error {
	var res TaskCreateRequest
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
